# 币安数据下载器使用说明

## 📋 概述

基于现有永续AI增强交易系统的数据获取模块，本文档提供完整的币安数据下载器使用说明，支持下载6个月历史K线数据、资金费率、持仓量等多维度市场数据。

**适用场景**: 量化交易、策略回测、市场分析、数据研究  
**数据源**: 币安期货API (Binance Futures API)  
**支持周期**: 1分钟、3分钟、5分钟、15分钟、30分钟、1小时、4小时、1天  
**历史范围**: 最长6个月历史数据  

---

## 🚀 快速开始

### 1. 环境准备

```bash
# 安装依赖
pip install requests pandas numpy datetime pathlib

# 创建数据目录
mkdir -p data/cache
mkdir -p data/basis_history  
mkdir -p data/fr_oi_history
```

### 2. 基础配置

```python
# 币安API配置
BINANCE_FAPI_BASE = "https://fapi.binance.com"

# 支持的时间周期
SUPPORTED_INTERVALS = ["1m", "3m", "5m", "15m", "30m", "1h", "4h", "1d"]

# 支持的主要交易对
SUPPORTED_SYMBOLS = ["BNBUSDT", "ETHUSDT", "BTCUSDT", "ADAUSDT", "SOLUSDT"]
```

---

## 📊 核心功能模块

### 1. K线数据下载器

#### 基础K线下载
```python
def fetch_klines(symbol: str, interval: str, limit: int = 1000) -> pd.DataFrame:
    """
    获取K线数据
    
    Args:
        symbol: 交易对符号 (如: "BNBUSDT")
        interval: K线周期 (如: "1m", "5m", "1h")
        limit: 获取根数 (最大1000)
        
    Returns:
        包含K线数据的DataFrame
    """
    url = f"{BINANCE_FAPI_BASE}/fapi/v1/klines"
    params = {
        "symbol": symbol,
        "interval": interval,
        "limit": min(limit, 1000)  # 币安API限制
    }
    
    response = requests.get(url, params=params, timeout=10)
    response.raise_for_status()
    
    data = response.json()
    
    # 转换为DataFrame
    df = pd.DataFrame(data, columns=[
        'open_time', 'open', 'high', 'low', 'close', 'volume',
        'close_time', 'quote_asset_volume', 'number_of_trades',
        'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'ignore'
    ])
    
    # 数据类型转换
    df['open_time'] = pd.to_datetime(df['open_time'], unit='ms')
    df['close_time'] = pd.to_datetime(df['close_time'], unit='ms')
    
    numeric_columns = ['open', 'high', 'low', 'close', 'volume', 
                      'quote_asset_volume', 'taker_buy_base_asset_volume', 
                      'taker_buy_quote_asset_volume']
    for col in numeric_columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')
    
    df['number_of_trades'] = pd.to_numeric(df['number_of_trades'], errors='coerce')
    
    return df
```

#### 批量历史数据下载
```python
def download_historical_data(symbol: str, interval: str, months: int = 6):
    """
    下载6个月历史数据
    
    Args:
        symbol: 交易对符号
        interval: K线周期
        months: 下载月数 (默认6个月)
    """
    from datetime import datetime, timedelta
    import time
    
    # 计算时间范围
    end_time = datetime.now()
    start_time = end_time - timedelta(days=months * 30)
    
    all_data = []
    current_time = start_time
    
    while current_time < end_time:
        # 每次获取1000根K线
        df = fetch_klines(symbol, interval, 1000)
        
        if df.empty:
            break
            
        all_data.append(df)
        
        # 更新时间到下一批
        current_time = df['close_time'].max()
        
        # 避免API限制
        time.sleep(0.1)
        
        print(f"已下载 {len(all_data)} 批数据，最新时间: {current_time}")
    
    # 合并所有数据
    final_df = pd.concat(all_data, ignore_index=True)
    final_df = final_df.drop_duplicates(subset=['open_time']).sort_values('open_time')
    
    # 保存数据
    cache_file = f"data/cache/{symbol}_{interval}.pkl"
    final_df.to_pickle(cache_file)
    
    print(f"✅ 数据下载完成: {len(final_df)} 条记录")
    print(f"📁 保存位置: {cache_file}")
    
    return final_df
```

### 2. 资金费率下载器

```python
def fetch_funding_rate_history(symbol: str, limit: int = 1000):
    """
    获取资金费率历史数据
    
    Args:
        symbol: 交易对符号
        limit: 获取条数 (最大1000)
    """
    url = f"{BINANCE_FAPI_BASE}/fapi/v1/fundingRate"
    params = {
        "symbol": symbol,
        "limit": min(limit, 1000)
    }
    
    response = requests.get(url, params=params, timeout=10)
    response.raise_for_status()
    
    data = response.json()
    
    df = pd.DataFrame(data)
    df['fundingTime'] = pd.to_datetime(df['fundingTime'], unit='ms')
    df['fundingRate'] = pd.to_numeric(df['fundingRate'])
    df['markPrice'] = pd.to_numeric(df['markPrice'])
    
    return df

def download_funding_rate_6months(symbol: str):
    """
    下载6个月资金费率数据
    """
    from datetime import datetime, timedelta
    
    all_data = []
    end_time = datetime.now()
    start_time = end_time - timedelta(days=180)  # 6个月
    
    # 分批下载
    current_time = start_time
    while current_time < end_time:
        df = fetch_funding_rate_history(symbol, 1000)
        if df.empty:
            break
            
        all_data.append(df)
        current_time = df['fundingTime'].max()
        time.sleep(0.1)
    
    # 合并数据
    final_df = pd.concat(all_data, ignore_index=True)
    final_df = final_df.drop_duplicates(subset=['fundingTime']).sort_values('fundingTime')
    
    # 保存数据
    cache_file = f"data/fr_oi_history/{symbol}_funding_rate_6months.csv"
    final_df.to_csv(cache_file, index=False)
    
    print(f"✅ 资金费率数据下载完成: {len(final_df)} 条记录")
    return final_df
```

### 3. 持仓量数据下载器

```python
def fetch_open_interest_history(symbol: str, period: str = "5m", limit: int = 1000):
    """
    获取持仓量历史数据
    
    Args:
        symbol: 交易对符号
        period: 数据周期 (5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d)
        limit: 获取条数
    """
    url = f"{BINANCE_FAPI_BASE}/fapi/v1/openInterestHist"
    params = {
        "symbol": symbol,
        "period": period,
        "limit": min(limit, 1000)
    }
    
    response = requests.get(url, params=params, timeout=10)
    response.raise_for_status()
    
    data = response.json()
    
    df = pd.DataFrame(data)
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df['sumOpenInterest'] = pd.to_numeric(df['sumOpenInterest'])
    df['sumOpenInterestValue'] = pd.to_numeric(df['sumOpenInterestValue'])
    
    return df

def download_oi_6months(symbol: str):
    """
    下载6个月持仓量数据
    """
    all_data = []
    end_time = datetime.now()
    start_time = end_time - timedelta(days=180)
    
    current_time = start_time
    while current_time < end_time:
        df = fetch_open_interest_history(symbol, "1h", 1000)
        if df.empty:
            break
            
        all_data.append(df)
        current_time = df['timestamp'].max()
        time.sleep(0.1)
    
    final_df = pd.concat(all_data, ignore_index=True)
    final_df = final_df.drop_duplicates(subset=['timestamp']).sort_values('timestamp')
    
    cache_file = f"data/fr_oi_history/{symbol}_open_interest_6months.csv"
    final_df.to_csv(cache_file, index=False)
    
    print(f"✅ 持仓量数据下载完成: {len(final_df)} 条记录")
    return final_df
```

### 4. 多空比数据下载器

```python
def fetch_long_short_ratio(symbol: str, period: str = "5m", limit: int = 1000):
    """
    获取多空比历史数据
    
    Args:
        symbol: 交易对符号
        period: 数据周期
        limit: 获取条数
    """
    url = f"{BINANCE_FAPI_BASE}/fapi/v1/globalLongShortAccountRatio"
    params = {
        "symbol": symbol,
        "period": period,
        "limit": min(limit, 1000)
    }
    
    response = requests.get(url, params=params, timeout=10)
    response.raise_for_status()
    
    data = response.json()
    
    df = pd.DataFrame(data)
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df['longShortRatio'] = pd.to_numeric(df['longShortRatio'])
    df['longAccount'] = pd.to_numeric(df['longAccount'])
    df['shortAccount'] = pd.to_numeric(df['shortAccount'])
    
    return df
```

---

## 🔧 完整下载脚本

### 一键下载6个月数据

```python
#!/usr/bin/env python3
"""
币安数据下载器 - 6个月历史数据批量下载
"""

import os
import time
import requests
import pandas as pd
from datetime import datetime, timedelta
from pathlib import Path

class BinanceDataDownloader:
    def __init__(self, base_url="https://fapi.binance.com"):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
    
    def download_klines_6months(self, symbol: str, interval: str):
        """下载6个月K线数据"""
        print(f"🚀 开始下载 {symbol} {interval} 6个月K线数据...")
        
        all_data = []
        end_time = datetime.now()
        start_time = end_time - timedelta(days=180)
        
        current_time = start_time
        batch_count = 0
        
        while current_time < end_time:
            try:
                # 获取数据
                df = self.fetch_klines(symbol, interval, 1000)
                
                if df.empty:
                    print("⚠️ 没有更多数据，下载完成")
                    break
                
                all_data.append(df)
                batch_count += 1
                current_time = df['close_time'].max()
                
                print(f"📊 批次 {batch_count}: {len(df)} 条数据, 最新时间: {current_time}")
                
                # API限制保护
                time.sleep(0.1)
                
            except Exception as e:
                print(f"❌ 下载失败: {e}")
                time.sleep(1)
                continue
        
        if all_data:
            # 合并数据
            final_df = pd.concat(all_data, ignore_index=True)
            final_df = final_df.drop_duplicates(subset=['open_time']).sort_values('open_time')
            
            # 保存数据
            os.makedirs("data/cache", exist_ok=True)
            cache_file = f"data/cache/{symbol}_{interval}.pkl"
            final_df.to_pickle(cache_file)
            
            print(f"✅ K线数据下载完成: {len(final_df)} 条记录")
            print(f"📁 保存位置: {cache_file}")
            print(f"📅 时间范围: {final_df['open_time'].min()} ~ {final_df['open_time'].max()}")
            
            return final_df
        else:
            print("❌ 没有下载到任何数据")
            return pd.DataFrame()
    
    def download_funding_rate_6months(self, symbol: str):
        """下载6个月资金费率数据"""
        print(f"💰 开始下载 {symbol} 6个月资金费率数据...")
        
        all_data = []
        end_time = datetime.now()
        start_time = end_time - timedelta(days=180)
        
        current_time = start_time
        batch_count = 0
        
        while current_time < end_time:
            try:
                df = self.fetch_funding_rate_history(symbol, 1000)
                
                if df.empty:
                    break
                
                all_data.append(df)
                batch_count += 1
                current_time = df['fundingTime'].max()
                
                print(f"💰 批次 {batch_count}: {len(df)} 条数据")
                time.sleep(0.1)
                
            except Exception as e:
                print(f"❌ 资金费率下载失败: {e}")
                time.sleep(1)
                continue
        
        if all_data:
            final_df = pd.concat(all_data, ignore_index=True)
            final_df = final_df.drop_duplicates(subset=['fundingTime']).sort_values('fundingTime')
            
            os.makedirs("data/fr_oi_history", exist_ok=True)
            cache_file = f"data/fr_oi_history/{symbol}_funding_rate_6months.csv"
            final_df.to_csv(cache_file, index=False)
            
            print(f"✅ 资金费率数据下载完成: {len(final_df)} 条记录")
            return final_df
        
        return pd.DataFrame()
    
    def download_oi_6months(self, symbol: str):
        """下载6个月持仓量数据"""
        print(f"📊 开始下载 {symbol} 6个月持仓量数据...")
        
        all_data = []
        end_time = datetime.now()
        start_time = end_time - timedelta(days=180)
        
        current_time = start_time
        batch_count = 0
        
        while current_time < end_time:
            try:
                df = self.fetch_open_interest_history(symbol, "1h", 1000)
                
                if df.empty:
                    break
                
                all_data.append(df)
                batch_count += 1
                current_time = df['timestamp'].max()
                
                print(f"📊 批次 {batch_count}: {len(df)} 条数据")
                time.sleep(0.1)
                
            except Exception as e:
                print(f"❌ 持仓量下载失败: {e}")
                time.sleep(1)
                continue
        
        if all_data:
            final_df = pd.concat(all_data, ignore_index=True)
            final_df = final_df.drop_duplicates(subset=['timestamp']).sort_values('timestamp')
            
            os.makedirs("data/fr_oi_history", exist_ok=True)
            cache_file = f"data/fr_oi_history/{symbol}_open_interest_6months.csv"
            final_df.to_csv(cache_file, index=False)
            
            print(f"✅ 持仓量数据下载完成: {len(final_df)} 条记录")
            return final_df
        
        return pd.DataFrame()
    
    def fetch_klines(self, symbol: str, interval: str, limit: int):
        """获取K线数据"""
        url = f"{self.base_url}/fapi/v1/klines"
        params = {"symbol": symbol, "interval": interval, "limit": limit}
        
        response = self.session.get(url, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        
        df = pd.DataFrame(data, columns=[
            'open_time', 'open', 'high', 'low', 'close', 'volume',
            'close_time', 'quote_asset_volume', 'number_of_trades',
            'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'ignore'
        ])
        
        # 数据类型转换
        df['open_time'] = pd.to_datetime(df['open_time'], unit='ms')
        df['close_time'] = pd.to_datetime(df['close_time'], unit='ms')
        
        numeric_columns = ['open', 'high', 'low', 'close', 'volume', 
                          'quote_asset_volume', 'taker_buy_base_asset_volume', 
                          'taker_buy_quote_asset_volume']
        for col in numeric_columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        
        df['number_of_trades'] = pd.to_numeric(df['number_of_trades'], errors='coerce')
        
        return df
    
    def fetch_funding_rate_history(self, symbol: str, limit: int):
        """获取资金费率历史数据"""
        url = f"{self.base_url}/fapi/v1/fundingRate"
        params = {"symbol": symbol, "limit": limit}
        
        response = self.session.get(url, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        df = pd.DataFrame(data)
        df['fundingTime'] = pd.to_datetime(df['fundingTime'], unit='ms')
        df['fundingRate'] = pd.to_numeric(df['fundingRate'])
        df['markPrice'] = pd.to_numeric(df['markPrice'])
        
        return df
    
    def fetch_open_interest_history(self, symbol: str, period: str, limit: int):
        """获取持仓量历史数据"""
        url = f"{self.base_url}/fapi/v1/openInterestHist"
        params = {"symbol": symbol, "period": period, "limit": limit}
        
        response = self.session.get(url, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        df = pd.DataFrame(data)
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df['sumOpenInterest'] = pd.to_numeric(df['sumOpenInterest'])
        df['sumOpenInterestValue'] = pd.to_numeric(df['sumOpenInterestValue'])
        
        return df

def main():
    """主函数 - 批量下载数据"""
    
    # 配置参数
    SYMBOLS = ["BNBUSDT", "ETHUSDT", "BTCUSDT"]
    INTERVALS = ["1m", "5m", "15m", "1h"]
    
    # 创建下载器
    downloader = BinanceDataDownloader()
    
    print("🚀 开始批量下载币安6个月历史数据...")
    print(f"📊 交易对: {SYMBOLS}")
    print(f"⏰ 时间周期: {INTERVALS}")
    print("=" * 50)
    
    # 下载K线数据
    for symbol in SYMBOLS:
        for interval in INTERVALS:
            try:
                downloader.download_klines_6months(symbol, interval)
                print(f"✅ {symbol} {interval} 下载完成")
            except Exception as e:
                print(f"❌ {symbol} {interval} 下载失败: {e}")
            
            time.sleep(1)  # 避免API限制
    
    # 下载资金费率数据
    for symbol in SYMBOLS:
        try:
            downloader.download_funding_rate_6months(symbol)
            print(f"✅ {symbol} 资金费率下载完成")
        except Exception as e:
            print(f"❌ {symbol} 资金费率下载失败: {e}")
        
        time.sleep(1)
    
    # 下载持仓量数据
    for symbol in SYMBOLS:
        try:
            downloader.download_oi_6months(symbol)
            print(f"✅ {symbol} 持仓量下载完成")
        except Exception as e:
            print(f"❌ {symbol} 持仓量下载失败: {e}")
        
        time.sleep(1)
    
    print("🎉 所有数据下载完成！")
    print("📁 数据保存位置:")
    print("   - K线数据: data/cache/")
    print("   - 资金费率: data/fr_oi_history/")
    print("   - 持仓量: data/fr_oi_history/")

if __name__ == "__main__":
    main()
```

---

## 📋 使用示例

### 1. 单次下载示例

```python
# 创建下载器
downloader = BinanceDataDownloader()

# 下载BNBUSDT 1分钟K线数据 (6个月)
df = downloader.download_klines_6months("BNBUSDT", "1m")

# 下载资金费率数据
fr_df = downloader.download_funding_rate_6months("BNBUSDT")

# 下载持仓量数据
oi_df = downloader.download_oi_6months("BNBUSDT")
```

### 2. 批量下载示例

```python
# 批量下载多个交易对
symbols = ["BNBUSDT", "ETHUSDT", "BTCUSDT"]
intervals = ["1m", "5m", "15m", "1h"]

for symbol in symbols:
    for interval in intervals:
        downloader.download_klines_6months(symbol, interval)
        time.sleep(1)  # 避免API限制
```

### 3. 数据验证示例

```python
# 验证下载的数据
def validate_data(df, data_type="K线"):
    print(f"📊 {data_type}数据验证:")
    print(f"   数据量: {len(df)} 条")
    print(f"   时间范围: {df.index.min()} ~ {df.index.max()}")
    print(f"   缺失值: {df.isnull().sum().sum()}")
    print(f"   数据类型: {df.dtypes.to_dict()}")

# 验证K线数据
df = pd.read_pickle("data/cache/BNBUSDT_1m.pkl")
validate_data(df, "K线")
```

---

## ⚙️ 配置参数

### API限制配置

```python
# API请求限制
API_CONFIG = {
    "max_requests_per_second": 10,      # 每秒最大请求数
    "request_delay": 0.1,               # 请求间隔(秒)
    "timeout": 10,                      # 请求超时(秒)
    "max_retries": 3,                   # 最大重试次数
    "backoff_factor": 1.0               # 重试退避因子
}
```

### 数据存储配置

```python
# 数据存储配置
STORAGE_CONFIG = {
    "cache_dir": "data/cache",          # K线数据目录
    "fr_oi_dir": "data/fr_oi_history",  # 资金费率/持仓量目录
    "basis_dir": "data/basis_history", # 基差数据目录
    "backup_dir": "data/backup"         # 备份目录
}
```

### 下载范围配置

```python
# 下载范围配置
DOWNLOAD_CONFIG = {
    "months": 6,                        # 下载月数
    "symbols": ["BNBUSDT", "ETHUSDT", "BTCUSDT"],  # 交易对列表
    "intervals": ["1m", "5m", "15m", "1h"],        # 时间周期列表
    "auto_retry": True,                 # 自动重试
    "save_format": "pkl"                # 保存格式 (pkl/csv/json)
}
```

---

## 🔍 数据质量检查

### 1. 数据完整性检查

```python
def check_data_integrity(df, expected_interval="1m"):
    """检查数据完整性"""
    
    # 检查时间间隔
    time_diff = df['open_time'].diff().dropna()
    expected_minutes = {"1m": 1, "5m": 5, "15m": 15, "1h": 60}
    expected_diff = expected_minutes.get(expected_interval, 1)
    
    irregular_intervals = time_diff[time_diff != pd.Timedelta(minutes=expected_diff)]
    
    print(f"📊 数据完整性检查:")
    print(f"   总数据量: {len(df)} 条")
    print(f"   时间范围: {df['open_time'].min()} ~ {df['open_time'].max()}")
    print(f"   异常间隔: {len(irregular_intervals)} 个")
    print(f"   缺失值: {df.isnull().sum().sum()} 个")
    
    return len(irregular_intervals) == 0
```

### 2. 数据准确性检查

```python
def check_data_accuracy(df):
    """检查数据准确性"""
    
    # 检查价格逻辑
    price_errors = df[(df['high'] < df['low']) | 
                     (df['high'] < df['open']) | 
                     (df['high'] < df['close']) |
                     (df['low'] > df['open']) | 
                     (df['low'] > df['close'])]
    
    # 检查成交量
    volume_errors = df[df['volume'] < 0]
    
    print(f"🔍 数据准确性检查:")
    print(f"   价格逻辑错误: {len(price_errors)} 条")
    print(f"   成交量错误: {len(volume_errors)} 条")
    print(f"   数据质量: {'✅ 良好' if len(price_errors) == 0 and len(volume_errors) == 0 else '❌ 有问题'}")
    
    return len(price_errors) == 0 and len(volume_errors) == 0
```

---

## 🚨 注意事项

### 1. API限制
- **请求频率**: 币安API限制每秒最多10个请求
- **数据量限制**: 单次请求最多1000条数据
- **IP限制**: 同一IP有请求频率限制

### 2. 网络稳定性
- **超时设置**: 建议设置10秒超时
- **重试机制**: 网络失败时自动重试
- **断点续传**: 支持中断后继续下载

### 3. 数据存储
- **磁盘空间**: 6个月数据约需要1-2GB空间
- **文件格式**: 建议使用Pickle格式保存
- **备份策略**: 重要数据需要定期备份

### 4. 法律合规
- **使用条款**: 遵守币安API使用条款
- **数据用途**: 仅用于研究和学习目的
- **商业使用**: 商业使用需要获得授权

---

## 📞 技术支持

### 常见问题

**Q: 下载速度很慢怎么办？**
A: 可以调整请求间隔，但不要低于0.1秒，避免触发API限制。

**Q: 数据不完整怎么办？**
A: 检查网络连接，使用重试机制，或者分段下载。

**Q: 如何验证数据质量？**
A: 使用提供的数据质量检查函数，检查时间间隔、价格逻辑等。

**Q: 支持哪些交易对？**
A: 支持币安期货所有交易对，建议使用主流交易对如BNBUSDT、ETHUSDT、BTCUSDT。

### 联系方式

- **GitHub**: 项目仓库地址
- **文档**: 详细使用文档
- **社区**: 技术交流群

---

## 📝 更新日志

### v1.0.0 (2025-10-16)
- ✅ 初始版本发布
- ✅ 支持6个月历史数据下载
- ✅ 支持K线、资金费率、持仓量数据
- ✅ 完整的数据质量检查
- ✅ 批量下载功能

---

**📚 本说明文档基于现有永续AI增强交易系统，提供完整的币安数据下载解决方案。如有问题，请参考项目文档或联系技术支持。**
